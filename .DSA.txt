General:
ASCII Values of letters
A-Z -> 65 to 90
a-z -> 97 to 122

const auto var_name =(data_type) value; -> to store constant value in a variable
int -> -2^31 to 2^31 -1 
unsigned int -> 0 to 2^32 -1
long long-> -2^63  to 2^63 -1

Operators:
% -> need two int operands(any qualifier like long,unsigned)

Array:
data_type arr [size]; (declaring static array) -> Size should not be a variable

Vector:
#include <vector>

Iterator(pointer for array, iterator for vector)
Example
vector<int>::iterator p; -> same as pointer to int
p=arr.begin();

vector<data_type> array_name (declaring dynamic array)
for example : vector<int> arr;
vector<vector<int>> arr;
vector<int> arr(size,value); -> Size can be variable or constant. Default value is 0 which is assigned to every element.

arr.size()
arr.push_back()
arr.pop_back()
arr.insert(iterator,freq,value) 
arr.end() -> iterator to last element+1
arr.begin() -> iterator to first element
arr.rbegin() -> iterator to last element
arr.rend() -> iterator to start element - 1
arr.clear()

Math:
#include <math.h>

max(num1,num2)
min(num1,num2)
sqrt(num1)
pow(base,exp) -> returns double 
gcd(num1,num2)
abs(num1)
floor(num)
ceil(num)

#include <algorithm>
swap(num1,num2)  -> works for arrays as well
reverse(iterator1,iterator2)
count(iterator1,iterator2,element)
min({1,2,3}) -> No array variables allowed
max({2,3,4}) -> No array variables allowed

#include <numeric>
accumulate(iterator1,iterator2,start_value_of_sum)

#include <utility>
exchange(num,new_value) -> will return old value and replace with new value

#include <ctype.h>
toupper()
tolower()
isupper()
islower()
isalpha()
isdigit()


Techniques:
1. Fast pow
while (exp > 0) {
        if (exp % 2 == 1) {        // if exponent is odd
            result = (result * base) % mod;
        }
        base = (base * base) % mod;       // square the base
        exp /= 2;                  // divide exponent by 2
    }

String:
#include <string> 
Strings are dynamic 1-D character containers
to_string()
stoi()
.substr(start_position,number_of_characters)
string(1,character) -> to convert character to string
.find(char_or_string) -> returns first index where found

stringstream s(text);  ->stores individual words that are seperated by spaces present in the string text
s>>word -> access word
s<<word -> add word


Matrix:
2-D array is an array inside an array

data_type array_name [rows][columns] (declaring 2-d static array)

vector<vector<data_type>> arr (declaring 2-d dynamic array)
vector<vector<int>> arr(5,<vector>int(4,0)) -> initializing a 5 row 4 col matrix with 0
Matrix is a 2d static array and is also an application of 2-d dynamic arrays with rows and columns. The size of the array inside the bigger array is constant.
int row =arr.size();
int col=arr[0].size();


Stack:
Stack follow LIFO
stack<data_type> stack_name;
s.push();
s.pop();
s.size();
s.empty();
s.top();


Queue:
Queue follow FIFO
queue <data_type> queue_name;
q.push();
q.pop();  -> pops first element (FIFO)
q.size();
q.empty();
q.back();
q.front();


Recursion is calling a function in the same function. The function will keep calling until a value is returned.  
Time complexity: No of calls * no of steps in each call
Space complexity: No of calls * extra memory in each call

Binary search is used when the array is monotonic i.e when it is increasing/decreasing. 
Binary search is better than linear search as it reduces the number of iterations O(log n). 
One disadvantage of binary search is that it might not return the first index where found.
Code(for increasing):

Iterative:
int start=0;
int end = arr.size()-1;
while(start<=end){
       int mid= (start+end)/2;
       if(arr[mid]==key){
         return mid;
       }
       else if(arr[mid]>key){
         end=mid-1;
       }
       else{
         start=mid+1;
       }
}
return -1;

Recursive:
int bin_r(int* a,int l,int h,int key){
if(l>h){
        return -1;
   }
int mid=(l+h)/2;
if(a[mid]==key){
    return mid;
}
else if(a[mid]>key){
    return bin_r(a,l,mid-1,key);
}
else{
    return bin_r(a,mid+1,h,key);
}
}

Sort STL: sort(arr.begin(),arr.end());
Sorting is to arrange the values in increasing/decreasing order
O(n^2)
1. Selection sort
Code (for arranging in increasing order):
for(int i = 0; i < n-1; i++ ) {
        int minIndex = i;
        
        for(int j = i+1; j<n; j++) {
            
            if(arr[j] < arr[minIndex]) 
                minIndex = j;
            
        }
        swap(arr[minIndex], arr[i]);
    }
As the rounds/iterations of i proceed, the elements are sorted from the left(smallest to largest)

2. Bubble Sort
Code(for arranging in increasing order):
 for(int i = 0; i<n-1; i++) {
           
        for(int j =0; j<(n-1)-i; j++) {
            
            if(arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
            }
            
        }
        
}
As the rounds/iterations of i proceed, the elements are sorted from the right(largest to smallest)

3. Insertion Sort
Code(for arranging in increasing order):

for(int i = 1; i<n; i++) {
        int temp = arr[i];
        int j = i-1;
        for(; j>=0; j--) {
            
            if(arr[j] > temp) {
                
                arr[j+1] = arr[j];
            }
            else { 
                break;
            }
            
        }
        
        arr[j+1] = temp;  
    } 

OOPS:
Objects - attributes and methods
class - blueprint
class demo {
 private:
  int salary 
 public : 
  string name;
  int id;
  void set_name(string s) { name = s; }
  void set_sal(int sal) { salary = sal; } //setter - to set values of private attributes
  void get_sal() { return salary; } //getter - to get values of private attributes
};
private,public - Access modifiers
encapsulation - binding attributes and methods, used for data hiding
constructor - to create space(automatic) or initialize the values of attributes(programmer defined)
class demo {
 private:
  int salary 
 public : 
  string name;
  int id;
  demo(){
    cout<<"Hi its the constructor";
    name="josh";
  }
  demo(string name){ //parameterized and constructor overloading
   this->name=name;  // this is pointer to object 
}
  demo(demo obj){ //copy constructor - shallow and deep
    this->name=obj.name;
    this->id=obj.id;
  }
  ~demo(){ //destructor called when exiting main function
    cout<<"Hi I am a destructor";
  }

};
Inheritence -
class demo{
    public:
    int a;
    demo(){ //parent constructor invoked first
        cout<<"Parent constructor";
    }
};
class demo1 : public demo{
    public:
    int b;
    demo1(int b,int a){
        cout<<"Child constructor";
        this->b=b;
        this->a=a;
    }
};

Polymorphism - constructor overloading, function overloading, function overridding
class demo{
    public:
    int a;
    void pri(int c){//function overloading - different arguments same name
        cout<<c;
    }
    void pri(char c){
        cout<<c;
    }
};
class demo1 : public demo{
    public:
    int b;
    void pri(int c){//function overridding - same arguments same name but when object of child is created, this is called
        cout<<"over-riding";
    }
};
Linked List: Linear non continuous data structure
Accessing a element - O(n) unlike O(1) for array
class NODE{
    public:
    int data;
    NODE* next;
    NODE(int val){
        data=val;
        next=NULL;
    }
};
class List{
    private:
    NODE* head;
    NODE* tail;
    public:
    List(){
        head=tail=NULL;
    }
    void push_front(int val){
        NODE* newnode=new NODE(val); //dynamic allocation
        if(head==NULL){
            head=tail=newnode;
        }
        else{
            newnode->next=head;
            head=newnode;
        }
    }
    void push_back(int val){
        NODE* newnode=new NODE(val);
        if(tail==NULL){
            head=tail=newnode;
        }
        else{
            tail->next=newnode;
            tail=newnode;
        }
    }
    void pop_front(){
        if(head){
        NODE* temp=head->next;
        delete head;
        head=temp;
        if(head == NULL){
            tail = NULL;
        }
        }
    }
    void pop_back(){
        if(head!=NULL && head->next!=NULL){
            NODE* temp=head;
            while(temp->next->next!=NULL){
                temp=temp->next;
            }
            
            delete temp->next;
            temp->next=NULL;
            tail=temp;
        }
        else if(head!=NULL){ //else is also fine as delete NULL does nothing
            delete head;
            head=tail=NULL; 
        }
    }
    void insert(int val,int pos){
        if(pos==0){
            push_front(val);
        }
        else{
        NODE* newnode=new NODE(val);
        NODE* temp=head;
        int i=0;
        while(i<pos){
            temp=temp->next;
            i++;
        }
        NODE* temp1=temp->next;
        temp->next=newnode;
        newnode->next=temp1;
        }
    }
    void search(int val){
        int i=0;
        NODE *temp=head;
        while(temp!=NULL){
            if(temp->data==val){
                cout<<i<<endl;
                return ;
            }
            temp=temp->next;
            i++;
        }
        cout<<"NOT found"<<endl;
    }
    void printLL(){
        NODE* temp=head;
        while(temp!=NULL){
            cout<<temp->data<<endl;
            temp=temp->next;
        }
    }
};
int main()
{
    List ll;
    for(int i=1;i<=10;i++){
        ll.push_back(i);
    }
    ll.pop_front();
    ll.search(3);
}
